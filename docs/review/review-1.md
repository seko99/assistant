Innokentiy / Virtual Podcast — Code Review (концепт)

Кратко: архитектура внятная и модульная (core / podcast / utils), есть базовые тесты и CLI. Решение позиционируется как концепт — это заметно по уровню логирования, обработке ошибок и ряду несоответствий конфигов/документации. Ниже — прицельные замечания и предложения улучшений, отсортированные по приоритету.

Сильные стороны

- Модульность: разбиение на `core` (wake word/ASR/TTS/LLM), `podcast` (сессия/персоны/оркестратор/контекст), `utils` (конфиги/фильтры/аудио).
- Чёткий поток в `main.py` и в оркестраторе подкаста; хорошие дефолты, fallback-режим LLM.
- Тесты покрывают ключевые элементы подкаста и фильтры текста; есть CLI для подкаста.
- Конфиг JSON гибкий, поддерживает разные режимы и профили участников.

Ключевые проблемы (P0)

- utils/text_filters.py: несоответствие тега thinking
  - Функции `filter_thinking_blocks`, `has_thinking_blocks`, `extract_thinking_content` используют шаблоны `<think>...</think>`, тогда как докстринги и тест-кейсы используют `<thinking>...</thinking>`. Это приведёт к некорректной фильтрации и падению тестов.
  - Рекомендация: заменить паттерны на `<thinking>.*?</thinking>` и (опционально) поддержать оба тега для совместимости.

- Потенциальные гонки при смене состояний записи
  - В `main.SpeechAssistant` таймер останавливает запись через `self._stop_recording_and_process` из отдельного потока, без захвата `recording_lock`, тогда как `audio_callback` вызывает ту же функцию из-под локa. Возможны состояния, когда буфер меняется параллельно смене `state`/таймера.
  - Рекомендация: унифицировать смену состояния/сброс таймера под одним локом; добавить простую атомарную защиту (флаг "stopping") и идемпотентность остановки.

- Дублирующееся/конфликтное имя ключей в utils/config_keys.py
  - Внутри `ConfigKeys` поле `LLM` сначала присваивается строке `'llm'`, затем перезаписывается классом `LLMKeys`. Сейчас код опирается на `ConfigKeys.LLM.LLM` (класс.контантa), но это хрупко и может ввести в заблуждение.
  - Рекомендация: разделить: например, `ConfigSections.LLM = 'llm'` и `ConfigKeysLLM = LLMKeys`; в `ConfigKeys` не переопределять одно и то же имя.

Важные замечания (P1)

- TTS: загрузка через `torch.hub.load` (Silero)
  - Требует сети/кэша и может падать в офлайн-среде. Нет механизма graceful fallback/кэширующего пути. Также не используются настройки устройства вывода (`assistant.playback_device`).
  - Рекомендации: поддержать локальный путь к модели/кэшу, возможность отключать аудио (только сохранение в файл), выбирать аудиоустройство через конфиг; логгировать предупреждения вместо фатальных ошибок.

- ASR: временный WAV в корне проекта
  - `core/speech_recognition.py` записывает `temp_recording_*.wav` в рабочую директорию, затем пытается удалить. Это шумит репозиторий и потенциально оставляет мусор при сбоях.
  - Рекомендации: использовать `tempfile.NamedTemporaryFile(delete=False)` с системным временным каталогом; учитывать флаг `transcription.save_audio_files`/`auto_delete_audio` из конфига (сейчас не используются).

- Аудио утилиты: возможное переполнение при конвертации
  - `convert_float32_to_int16` просто умножает на 32767 без клиппинга. При значениях вне [-1, 1] получится искажение.
  - Рекомендация: добавить `np.clip(audio_data, -1.0, 1.0)` перед преобразованием.

- Оркестратор: тестовые ожидания vs реальный код
  - В корне есть скрипты `test_podcast_fix.py`/`test_code_changes.py` с ожиданиями удаления `_moderator_transition`, тогда как метод в `podcast/orchestrator.py` присутствует и вызывается. Эти тесты не в папке `tests/` и носят характер артефактов миграции — но это источники путаницы.
  - Рекомендация: либо синхронизировать логику (удалить/обновить метод и вызовы), либо удалить/архивировать устаревшие тестовые скрипты.

- Журналирование и уровни логов
  - Везде используются `print` с эмодзи. Для концепта ок, но тяжело поддерживать/фильтровать. Нет уровней (`DEBUG/INFO/WARN/ERROR`) и нет единого форматирования/идентификаторов сессий.
  - Рекомендация: перейти на `logging` c конфигурируемым уровнем и компактным форматом; оставить эмодзи только в CLI-режиме.

- LLMEngine: инициализация и история
  - При `initialize()` выполняется пробный `chat.completions.create(...)` — это может быть медленно/нестабильно и бессмысленно с точки зрения состояния диалога. В истории хранятся все сообщения без обрезки.
  - Рекомендации: легковесная проверка доступности (например, `models.list()` если доступно, либо короткий HEAD/PING), троттлинг/таймаут; периодически обрезать историю; использовать `clean_llm_response` вместо частного фильтра.

Замечания среднего приоритета (P2)

- Документация vs код
  - README перечисляет состояние `PROCESSING`, в коде — `THINKING` (`utils/enums.py`). Стоит синхронизировать термины.
  - В README/конфиге присутствуют ключи, которые не используются (например, часть `audio.*`, `assistant.playback_device`). Хорошо бы вычистить/задействовать.

- Паузы и калибровка шума
  - `PauseDetector` калибруется по первым 10 чанкам и использует `mean * 2`. Возможны ложные срабатывания в шумной среде/шуме на старте.
  - Рекомендации: делать калибровку при входе в состояние `RECORDING`, поддержать экспоненциальную аппроксимацию шума/адаптацию порога, сделать `samples_per_second` целым и хранить длительности с большей точностью.

- Поток воспроизведения TTS
  - `sd.play(...)` + `sd.wait()` блокируют поток. Для подкаста-генератора это ок, для ассистента в реальном времени — обсудить неблокирующий вывод или отдельный поток/очередь воспроизведения, плюс отмену при новых командах.

- Смешение RU/EN в коде и доках
  - Нормально для концепта, но полезно выбрать единый стиль и выдержать переводы терминов (особенно в промптах и логах).

- Дублирование логики LLM сессий
  - Есть и `LLMEngine` с общей историей, и `LLMSession` со своей; пересечения функционала. Можно унифицировать API и переиспользовать одну реализацию истории.

- Тесты: надёжность и стиль
  - Смешаны `pytest` и `unittest`; тесты в корне используют абсолютные пути (`/home/seko/...`), что ломает переносимость. Неплохо бы выровнять на `pytest`, сделать относительные пути, структурировать фикстуры и маркировки.

Мелкие/точечные замечания

- `core/speech_recognition.py`: параметр `word_timestamps=False` — возможно, стоит сделать настраиваемым через конфиг.
- `core/wake_word.py`: используется только `AcceptWaveform`, без обработки `PartialResult` — можно улучшить отзывчивость детектора.
- `podcast/context_enricher.py`: `WebSearchProvider` — заглушка; обрамить использование понятным сообщением/флагом и не поднимать исключение в `enrich_context` (сейчас перехватывается, но логика может выглядеть как ошибка).
- `podcast/orchestrator.py`: при сохранении MD полезно добавлять путь к аудио, если он есть (сейчас сохраняется только текст, аудиофайл остаётся в JSON, но не в MD).
- Конфиг `llm.base_url` сейчас указывает на LAN IP; в README — localhost. Уточнить значения по умолчанию.

Предлагаемые изменения (draft-план)

P0 (исправить в первую очередь)
- Исправить теги в `utils/text_filters.py` на `<thinking>...` (и поддержать `<think>` как расширение), синхронизировать `has_thinking_blocks`/`extract_thinking_content` с тестами.
- Защитить смену состояния записи в `main.SpeechAssistant` единым локом/флагом; сделать `_stop_recording_and_process` идемпотентным.
- Развести `ConfigKeys`: не переопределять `ConfigKeys.LLM`; ввести отдельные имена для секций и наборов ключей.

P1
- В `core/speech_recognition.py` перейти на `tempfile` + учет флагов `save_audio_files`/`auto_delete_audio`.
- В `utils/audio_utils.convert_float32_to_int16` добавить клиппинг.
- В `core/text_to_speech.py` добавить возможность указать устройство вывода и поддержку полного офлайн-кэша модели; graceful fallback при отсутствии сети.
- В оркестраторе: либо убрать `_moderator_transition` и вызовы, либо удалить устаревшие проверочные скрипты в корне.
- Перевести `print` на `logging` с уровнями и единым форматтером.

P2
- Синхронизировать README (состояния, параметры конфига) с текущей реализацией.
- Опционально: ограничивать длину истории LLM, поддержать `clean_llm_response` вместо частного фильтра, параметризовать beam size/язык через конфиг.
- Уточнить калибровку пауз, добавить адаптацию шума и тесты на реальные аудио-чанки.
- Привести тесты к единому стилю (`pytest`), убрать абсолютные пути, добавить CI-скрипт.

Быстрые победы (low effort → high value)

- Заменить паттерн в фильтрах `<thinking>` и добавить клиппинг аудио в одну строку — сразу повысит корректность работы и устойчивость.
- Применить `tempfile` для ASR и флаги конфига — уберёт мусор в репо.
- Неблокирующий (или опционально неблокирующий) TTS-поток и выбор устройства — улучшит UX.
- Вынести уровень логирования в конфиг и добавить `--verbose/--debug` поведение в CLI единообразно.

Общее резюме

Для концепта проект находится в хорошем состоянии: понятная архитектура, сквозной сценарий от wake word до TTS/LLM, зачатки тестов и документации. Для движения к production нужно: укрепить фильтрацию текста (thinking), синхронизировать конфиги/ключи, устранить гонки при остановке записи, улучшить управление ресурсами (временные файлы/аудио устройство/офлайн TTS), унифицировать логирование и тестовую базу.

